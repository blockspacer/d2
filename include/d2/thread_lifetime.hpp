/*!
 * @file
 * This file defines the `d2::thread_lifetime` class.
 */

#ifndef D2_THREAD_LIFETIME_HPP
#define D2_THREAD_LIFETIME_HPP

#include <d2/api.hpp>

#include <boost/assert.hpp>
#include <boost/smart_ptr/make_shared.hpp>
#include <boost/smart_ptr/shared_ptr.hpp>
#include <cstddef>
#include <dyno/thread_id.hpp>
#include <dyno/uniquely_identifiable.hpp>


namespace d2 {
/*!
 * Class defining a protocol allowing the library to track the lifetime of
 * threads.
 *
 * In order for the library to track the threads properly, the protocol
 * described below must be followed exactly. Threads not following the
 * protocol at all will be completely unknown to the library, and they
 * will not be tracked.
 *
 * First, an instance of `d2::thread_lifetime` must be created. Creating
 * the instance has noexcept guarantees and does not do much.
 *
 * Second, before the child thread is started, the `about_to_start()` method
 * must be called. This will allocate a small memory region that will be used
 * by the protocol. Then, the thread id of the parent thread will be saved
 * there.
 *
 * Third, the very first thing performed by the function executed in the child
 * thread must be to call the `just_started()` method. This means that the
 * `d2::thread_lifetime` instance needs to be passed on to the function in the
 * new thread. Calling `just_started()` will notify the library that a thread
 * was started, using the thread id stored in step 2 as the parent and the
 * current thread id as the child. The thread id stored in shared memory will
 * also be swapped so that it contains the thread id of the child thread
 * instead.
 *
 * The task of calling the `just_started()` method at thread startup can be
 * handled automatically by using the `d2::thread_function` wrapper.
 *
 * Finally, when the thread is joined, the `just_joined()` method must be
 * called from the joining thread. This will notify the library that a thread
 * was joined, using the thread id stored in shared memory as the child and
 * the current thread id as the parent. Using the current thread id as the
 * parent means that it is possible for a thread to be joined by another
 * thread than the one who started it.
 *
 * Also, if it happened for some reason that a thread is detached, i.e. that
 * it is not referenced by any of the other threads, the `just_detached()`
 * method must be called (from anywhere) immediately after the thread is
 * detached.
 *
 * @note Because `d2::thread_lifetime` is mainly a wrapper on top of a shared
 *       memory region, it has reference semantics even when copied, much like
 *       a `shared_ptr`.
 *
 * @note The amount of time between the call to e.g. `about_to_start()` and
 *       the actual starting of the thread has an impact on the precision
 *       of the tracking by the library (and so on for all the steps of the
 *       protocol). For example, as long as the call to `about_to_start()`
 *       happens in the parent thread and _before_ the thread is actually
 *       started, no deadlocks can be missed. However, if there is a large
 *       delay between the call to `about_to_start()` and the actual starting
 *       of the thread, more false positives could be reported because the
 *       library would erroneously consider the thread as alive (and thus able
 *       to deadlock with other threads) while it is not.
 *
 * @see `d2::trackable_thread` for a simple implementation of the protocol.
 *
 * @internal The default constructor is automatically generated by the
 *           compiler. Since the default constructor of `boost::shared_ptr`
 *           is noexcept, ours is too.
 */
struct thread_lifetime {
    void about_to_start() {
        BOOST_ASSERT_MSG(!data_, "called with a non-NULL data_ pointer");
        data_ = boost::make_shared<Data>();
        using dyno::unique_id;
        data_->parent = unique_id(dyno::this_thread::get_id());
    }

    void just_started() {
        BOOST_ASSERT_MSG(data_, "called with a NULL data_ pointer");

        using dyno::unique_id;
        std::size_t const child = unique_id(dyno::this_thread::get_id());
        BOOST_ASSERT_MSG(data_->parent != child,
            "called in the parent thread (or it appears so)");

        notify_start(data_->parent, child);
        data_->child = child;
    }

    void just_joined() {
        BOOST_ASSERT_MSG(data_, "called with a NULL data_ pointer");

        using dyno::unique_id;
        std::size_t const parent = unique_id(dyno::this_thread::get_id());
        BOOST_ASSERT_MSG(parent != data_->child,
            "called in the child thread (or it appears so)");

        notify_join(parent, data_->child);
        data_.reset();
    }

    /*!
     * @todo Support detached threads. See issue #18.
     * @internal Since the thread can be detached anytime and from any thread,
     *           we will need to use some kind of synchronization when we
     *           support this.
     */
    void just_detached() {
        BOOST_ASSERT_MSG(data_, "called with a NULL data_ pointer");
        data_.reset();
    }

private:
    union Data {
        std::size_t parent;
        std::size_t child;
    };
    boost::shared_ptr<Data> data_;
};
} // end namespace d2

#endif // !D2_THREAD_LIFETIME_HPP
