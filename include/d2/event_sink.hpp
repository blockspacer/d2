/**
 * This file defines the `EventSink` class.
 */

#ifndef D2_EVENT_SINK_HPP
#define D2_EVENT_SINK_HPP

#include <d2/detail/config.hpp>
#include <d2/detail/event_io.hpp>
#include <d2/events.hpp>

#include <boost/assert.hpp>
#include <boost/spirit/include/karma_format.hpp>
#include <cstddef>
#include <iterator>


namespace d2 {

/**
 * Interface used to log the events generated by the notification functions.
 * Runtime polymorphism is used because:
 *  - The ability to change sinks at runtime is desirable.
 *  - Having a stable ABI is a must because classes in this hierarchy will
 *    interact directly with client code.
 *  - The ability to customize the behavior of the event sink is desirable.
 */
class D2_API EventSink {
public:
    virtual void D2_API write(AcquireEvent const& event) = 0;
    virtual void D2_API write(ReleaseEvent const& event) = 0;
    virtual void D2_API write(StartEvent const& event) = 0;
    virtual void D2_API write(JoinEvent const& event) = 0;
    virtual D2_API ~EventSink();
};

namespace detail {
    extern event_generator<std::ostream_iterator<char> > generate_event;
}

/**
 * Adaptor to create an `EventSink` from an object implementing the `ostream`
 * interface.
 * @note This is probably going to be removed soon in favor of an event sink
 *       handling a repository.
 */
template <typename Ostream>
class OstreamEventSink : public EventSink {
    Ostream& os_;

    template <typename Event>
    void generate(Event const& event) {
        bool const success = boost::spirit::karma::generate(
                                std::ostream_iterator<char>(os_),
                                detail::generate_event << '\n',
                                event);

        BOOST_ASSERT_MSG(success,
                    "unable to generate the event using the karma generator");
    }

public:
    explicit OstreamEventSink(Ostream& os) : os_(os) { }

    virtual void write(AcquireEvent const& event) {
        generate(event);
    }

    virtual void write(ReleaseEvent const& event) {
        generate(event);
    }

    virtual void write(StartEvent const& event) {
        generate(event);
    }

    virtual void write(JoinEvent const& event) {
        generate(event);
    }
};

/**
 * Simple factory to create `OstreamEventSink`s.
 */
template <typename Ostream>
OstreamEventSink<Ostream> make_ostream_event_sink(Ostream* os) {
    return OstreamEventSink<Ostream>(os);
}

} // end namespace d2

#endif // !D2_EVENT_SINK_HPP
